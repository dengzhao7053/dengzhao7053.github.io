<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>注解解析之反射</title>
    <url>/2020/04/19/annotation2/</url>
    <content><![CDATA[<p>如果没有用来读取注解的工具，那注解也不会比注释更有用。使用注解的过程中，很重要的一个部分就是创建与使用注解处理器。<code>Java SE5</code> 扩展了<strong>反射机制</strong>的 <code>API</code>，以帮助程序员构造这类工具。</p>
<span id="more"></span>
<h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><p>反射类位于包<code>java.lang.reflect</code>，提供了一个接口<code>AnnotatedElement</code>，该接口主要有以下几个实现类：<code>Class</code>，<code>Constructor</code>，<code>Field</code>，<code>Method</code>，<code>Package</code>。调用<code>AnnotatedElement</code>对象的如下方法可以访问<code>Annotation</code>信息:</p>
<ul>
<li><code>getAnnotation(Class&lt;T&gt; annotationClass)</code>：返回该程序元素上存在的指定类型的注解，如果该类型的注解不存在，则返回<code>null</code>。</li>
<li><code>Annotation[] getAnnotations()</code>：返回此元素上存在的所有注释。</li>
<li><code>Annotation[] getDeclaredAnnotations()</code>：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。</li>
<li><code>boolean isAnnotationPresent(Class&lt;?extendsAnnotation&gt; annotationClass)</code>：判断该程序元素上是否存在指定类型的注释，存在返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2020/04/19/annotations/</url>
    <content><![CDATA[<p><strong>注解</strong>（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。</p>
<span id="more"></span>

<p>注解是众多引入到 <code>Java SE5</code> 中的重要语言变化之一。他们可以提供用来完整地描述程序所需的信息，而这些信息是无法用 <code>Java</code> 来表达的。因此，注解使得我们能够以将由编译器来测试和验证的格式，存储有关程序的额外信息。注解可以用来生成描述符文件，甚至或是新的类定义，并且有助于减轻编写“样板”代码的负担。通过使用注解，我们可以将这些元数据保存在 <code>Java</code> 源代码中，并利用 <code>annotation API</code> 为自己的注解构造处理工具，同时，注解的优点还包括：更加干净易读的代码以及编译期类型检查等。虽然 <code>Java SE5</code> 预先定义了一些元数据，但一般来说，主要还是需要程序员自己添加新的注解，并按照自己的方式使用他们。</p>
<h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><h3 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h3><p><code>Java SE5</code> 内置了3种标准注解，定义在 <code>java.lang</code> 中：</p>
<ul>
<li><code>@Override</code>，表示当前的方法定义将覆盖超类中的方法。</li>
<li><code>@Deprecated</code>，表示某一程序元素不建议使用了（过时了）。</li>
<li><code>@SuppressWarnings</code>，用于关闭不当的编译器警告信息。</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><code>Java</code>目前内置了四种元注解。元注解专职负责注解其他的注解：</p>
<ul>
<li><code>@Target</code>，表示该注解可以用于什么地方。可能的ElementType参数包括：<pre><code>      CONSTRUCTOR：构造器的声明
      FIELD：域声明
      LOCAL_VARIABLE：局部变量声明
      METHOD：方法声明
      PACKAGE：包声明
      PARAMETER：参数声明
      TYPE：类、接口或enum声明
</code></pre>
</li>
<li><code>@Retention</code>，表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括：<pre><code>      SUORCE：仅存在Java源文件，注解将被编译器丢弃。
      CLASS：注解在class文件中可用，但会被VM丢弃。
      RUNTIME：VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息。
</code></pre>
</li>
<li><code>@Documented</code>，将此注解包含在JavaDoc中。</li>
<li><code>@Inherited</code>，允许子类继承父类中的注解——如果某个类使用了@Xxx注解（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动被@Xxx修饰。</li>
</ul>
<h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>下边是创建的自定义注解，看起来很像接口的定义，事实上，与其它任何 <code>Java</code> 接口一样，注解也将会被编译成 <code>class</code> 文件。</p>
<pre><code>@Target(ElementType.Method)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test&#123;
    public int id();
    public String description() default &quot;no description&quot;;
&#125;
</code></pre>
<p>在注解中，一般都会包含一些元素以表示某些值。当分析处理注解时，程序或工具可以利用这些值。注解的元素看起来就像接口的方法，唯一的区别是你可以为其指定默认值。没有元素的注解称为标记注解（marker annotation）。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载过程</title>
    <url>/2020/04/14/classload/</url>
    <content><![CDATA[<p>这篇文章我们来了解<code>Java</code>虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化这五个阶段所执行的具体动作。</p>
<span id="more"></span>

<p><code>Java</code>虚拟机把描述类的数据从<code>Class</code>文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在<code>Java</code>语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。这种策略让<code>Java</code>语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为<code>Java</code>应用提供了极高的扩展性和灵活性。</p>
<h2 id="1-类加载的时机"><a href="#1-类加载的时机" class="headerlink" title="1. 类加载的时机"></a>1. 类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载<code>(Loading)</code>、验证<code>(Verification)</code>、准备<code>(Preparation)</code>、解析<code>(Resolution)</code>、初始化<code>(Initialization)</code>、使用<code>(Using)</code>和卸载<code>(Unloading)</code>七个阶段，其中验证、准备、解析三个部分统称为连接<code>(Linking)</code>。这七个阶段的发生顺序如图：<br><img src="classload.png" alt="流程"><br>图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这个顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这就是为了支持<code>Java</code>语言的运行时绑定特性(也称为动态绑定或晚期绑定)。请注意，这里写的是按部就班的开始，而不是按部就班地进行或者按部就班地完成，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自有把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前)：</p>
<p>1）遇到<code>new、getstatic、putstatic</code>或者<code>invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型<code>Java</code>代码场景有：</p>
<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段(被<code>final</code>修饰、已在编译期把结果放入常量池的静态字段除外)的时候</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
<p>2）使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</p>
<p>3）当初始化类的时候，如果发现父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>4）当虚拟机启动时，用户需要指定一个要执行的主类(包含<code>main</code>方法的那个类)，虚拟机会先初始化这个主类。</p>
<p>5）当使用JDK7新加入的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果为<code>REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
<p>6）当一个接口中定义了<code>JDK8</code>新加入的默认方法(被<code>default</code>关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
<h2 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2. 类的加载过程"></a>2. 类的加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”<code>(Loading)</code>阶段是整个“类加载”<code>(Class Loading)</code>过程中的一个阶段，不要混淆这两个看起来很相似的名词。在加载阶段，Java虚拟机需要完成以下三件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>相对于类加载过程的其他阶段，非数组类型的加载阶段(准确地说，是加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义类加载器去完成。对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终还是要靠类加载器来完成加载。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保<code>Class</code>文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证：</p>
<ol>
<li><p>文件格式验证：第一阶段要验证字节流是否符合<code>Class</code>文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数<code>0xCAFEBABE</code>开头</li>
<li>主次版本号是否在当前<code>Java</code>虚拟机接受范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
</ul>
<p>…</p>
<p> 实际上第一阶段的验证点还远不止这些，上面所列的只是从<code>HotSpot</code>虚拟机源码中摘抄的一小部分内容。这个阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入<code>Java</code>虚拟机内存中的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>
</li>
<li><p>元数据验证：第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类</li>
<li>这个类的父类是否继承了不允许继承的类(被final修饰的类)</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
</ul>
<p> …</p>
<p> 第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息</p>
</li>
<li><p>字节码验证：第三个阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕后，这阶段就要对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p>
</li>
<li><p>符号引用验证：最后一个阶段的校验行为发生在虚拟机将符号引用直接转化为直接饮用的时候，这个转化动作将在连接的第三阶段—-解析阶段中发生。符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验，通俗来说是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的可访问性是否可被当前类访问</li>
</ul>
<p> …</p>
</li>
</ol>
<p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序的全部代码已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量(即静态变量，被<code>static</code>修饰的变量)分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在<code>JDK7</code>及之前，<code>HotSpot</code>使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在<code>JDK8</code>及之后，类变量则会随着<code>Class</code>对象一起存放在<code>Java</code>堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p>
<p>关于准备阶段，还有两个容易产生混淆的概念需要这种强调，首先是这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>假设一个类变量的定义为：</p>
<p><code>public static int value = 123;</code></p>
<p>那变量<code>value</code>在准备阶段过后的初始值为0而不是123，因为这时尚未执行任何<code>Java</code>方法，而把<code>value</code>赋值为<code>123</code>的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把<code>value</code>赋值为123的动作要到类的初始化阶段才会被执行。</p>
<p>如果类字段的字段属性表中存在<code>Constant Value</code>属性，那在准备阶段变量值就会被初始化为<code>Constant Value</code>属性所指定的初始值，假设上面类变量<code>value</code>的定义修改为：</p>
<p><code>public static final int value = 123;</code></p>
<p>编译时Javac将会为value生成Constant Value属性，在准备阶段虚拟机就会根据Constant Value的设置将value赋值为123。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是<code>Java</code>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
<p>直接应用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段，<code>Java</code>虚拟机才真正开始执行类中编写的<code>Java</code>程序代码，将主导权移交给应用程序。</p>
<p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句可以赋值，但是不能访问。</p>
<p><code>&lt;clinit&gt;()</code>方法与类的构造函数不同，他不需要显式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器的双亲委派模型</title>
    <url>/2020/04/15/classload2/</url>
    <content><![CDATA[<p>一个类加载器收到了类加载的请求，它该如何去加载这个类呢？</p>
<span id="more"></span>

<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>双亲委派模型对于保证<code>Java</code>程序的稳定性运作很重要。使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是<code>Java</code>类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类<code>java.lang.Object</code>，它存放在<code>rt.java</code>之中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此<code>Object</code>类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行加载的话，如果用户自己写了一个名为<code>java.lang.Object</code>的类，并放在程序的<code>ClassPath</code>中，那系统中将会出现多个不同的<code>Object</code>类，<code>Java</code>类型体系中最基础的行为也就无从保证，应用程序也将会变得一片混乱。</p>
<p>综上，双亲委派模型的优点如下：</p>
<ul>
<li>避免重复加载，当父类加载器已经加载过该类时，子类加载器没必要再重复加载</li>
<li>安全性考虑，防止核心<code>API</code>库被随意篡改</li>
</ul>
<p>附:子加载器和父类加载器是继承关系吗？</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的创建</title>
    <url>/2020/03/30/createobj/</url>
    <content><![CDATA[<p><code>Java</code>是一门面向对象的编程语言，<code>Java</code>程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个<code>new</code>关键字而已，而在虚拟机中，普通<code>Java</code>对象的创建又是怎样一个过程呢？</p>
<span id="more"></span>

<p><code>Java</code>对象的创建包含以下几步：</p>
<h3 id="1-判断对象对应的类是否加载、链接和初始化"><a href="#1-判断对象对应的类是否加载、链接和初始化" class="headerlink" title="1.判断对象对应的类是否加载、链接和初始化"></a>1.判断对象对应的类是否加载、链接和初始化</h3><p>当<code>Java</code>虚拟机遇到一条字节码<code>new</code>指令时，首先先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。这部分细节将在后续的文章中呈现。</p>
<h3 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2.为对象分配内存"></a>2.为对象分配内存</h3><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务实际上便是等同于把一块确定大小的内存块从<code>Java</code>堆中划分出来。内存分配根据<code>Java</code>堆是否规整，有两种方式：</p>
<p>①指针碰撞：如果<code>Java</code>堆的内存是规整的，即所有用过的内存放在一边，而空闲的内存放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成内存分配的工作</p>
<p>②空闲列表：如果<code>Java</code>堆内存不是规整的，则需要由虚拟机维护一个列表来记录哪些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</p>
<p><code>Java</code>堆的内存分配是否规整根据所采用的垃圾收集器是否带有压缩整理功能有关。</p>
<h3 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3.处理并发问题"></a>3.处理并发问题</h3><p>除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来指针来分配内存的情况。解决这个问题有两种可选方案：</p>
<p>①对分配内存空间的动作进行同步处理，比如在虚拟机采用<code>CAS</code>算法并配上失败重试的方式保证更新操作的原子性。</p>
<p>②每个线程在<code>Java</code>堆中预先分配一小块内存，这块内存称为本地线程分配缓冲<code>(Thread Local Allocation Buffer, TLAB)</code>，线程需要分配内存时，就在对应线程的<code>TLAB</code>上分配内存，当线程中的<code>TLAB</code>用完并且被分配到了新的<code>TLAB</code>时，这时候才需要上述的同步锁定。</p>
<h3 id="4-初始化零值"><a href="#4-初始化零值" class="headerlink" title="4.初始化零值"></a>4.初始化零值</h3><p>将分配到的内存，除了对象头外都初始化零值。这步操作保证了对象的实例字段在<code>Java</code>代码中可以不赋值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="5-设置对象头"><a href="#5-设置对象头" class="headerlink" title="5.设置对象头"></a>5.设置对象头</h3><p>将对象的所属类、对象的<code>hashcode</code>和对象的<code>GC</code>分代年龄等数据存储在对象的对象头中。</p>
<h3 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6.执行init方法进行初始化"></a>6.执行init方法进行初始化</h3><p>执行<code>init</code>方法，初始化对象的成员变量、调用类的构造方法，这样一个对象就被创建了出来。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java对象</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集算法</title>
    <url>/2020/04/17/gc-method/</url>
    <content><![CDATA[<p>本文介绍常见的垃圾收集算法。</p>
<span id="more"></span>

<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最早出现也是最基础的垃圾收集算法是“标记-清除”算法。如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未标记的对象。标记过程就是对象是否属于垃圾的判定过程。</p>
<p>之所以说它是最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。它的主要缺点有两个：第一个是执行效率不稳定，如果<code>Java</code>堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>标记-复制算法常被简称为复制算法。它将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，若果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般不能直接选用这种算法。</p>
<p>针对老年代对象的存亡特征，提出了另一种有针对性的“标记-整理”算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：</p>
<p>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全部暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象的描述为<code>“Stop The World”</code>。</p>
<p>但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散与堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。内存的访问是用户程序最频繁的操作，甚至没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li>
</ol>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将<code>Java</code>堆划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把他们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<p>在<code>Java</code>堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中一个或者某部分的区域——因而才有了<code>“Minor GC”“Major GC”“Full GC”</code>这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记复制算法”“标记清除算法”“标记整理算法”等针对性的垃圾收集算法。</p>
<p>把分代收集理论具体放到现在的商用<code>Java</code>虚拟机里，设计者一般至少会把<code>Java</code>堆划分为新生代<code>(Young Generation)</code>和老年代<code>(Old Generation)</code>两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p>
<p>其实我们只要仔细思考一下，也很容易发现分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。假如要现在进行一次只局限于新生代区域内的收集<code>(Minor GC)</code>，但新生代中的对象是完全有可能被老年代所引用，为了找出该区域中的存活对象，不得不在固定的<code>GC Roots</code>之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p>
<ol start="3">
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数</li>
</ol>
<p>这其实是可根据前两条假说逻辑推理得出的隐含推论：存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p>
<p>依据这条假说，我们就不应再为了少数的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被称为“记忆集”)，这个结构把老年代划分成若干小块，标记出老年代的哪一块内存会存在跨代引用。此后发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Roots</code>进行扫描。虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说任然是划算的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>GC对象的判定方法</title>
    <url>/2020/04/16/gc-obj-decision-method/</url>
    <content><![CDATA[<p>在堆里面存放着<code>Java</code>世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经死去。</p>
<span id="more"></span>

<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>客观的说，引用计数算法虽然占用了一些额外的内存空间来进行计数，但他的原理简单，判断效率也很高，在大多数情况下他都是一个不错的算法。但是在<code>Java</code>领域，至少主流的<code>Java</code>虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用技术就很难解决对象之间相互循环引用的问题。两个对象互相引用对方，导致它们的引用计数都不为零，即使这两个对象已经不可能再被访问，引用计数算法也无法回收它们。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>当前主流的商用程序语言的内存管理子系统，都是通过可达性分析算法来判定对象是否存活。这个算法的基本思路就是通过一系列<code>GC Roots</code>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到<code>GC Roots</code>间没有任何引用链相连，或者用图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>在<code>Java</code>技术体系里面，固定可作为<code>GC Roots</code>的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、布局变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如<code>Java</code>类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用。</li>
<li>在本地方法栈中<code>JNI</code>引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的<code>Class</code>对象，一些常驻的异常对象(比如<code>NullPointException、OutOfMemoryError</code>)等，还有系统加载器。</li>
<li>所有被同步锁持有的对象。</li>
<li>反映<code>Java</code>虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地代码缓存等。</li>
</ul>
<p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize</code>方法。假如对象没有覆盖<code>finalize</code>方法，或者<code>finalize</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为确有必要执行<code>finalize</code>方法，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条虚拟机自动建立的、低调度优先级的<code>Finalizer</code>线程去执行它们的<code>finalize</code>方法。<code>finalize</code>方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对<code>F-Queue</code>中的对象进行第二次小规模标记，如果对象要在<code>finalize</code>中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那在第二次标记是它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle学习（二）：Project核心API</title>
    <url>/2023/07/04/gradle-project/</url>
    <content><![CDATA[<p>在Gradle术语中，一个项目（project）代表一个正在构建的组件（比如，一个JAR文件），或一个想要完成的目标，如部署应用程序。每个Gradle构建脚本build.gradle至少定义一个项目。当构建进程启动后，Gradle基于build.gradle中的配置实例化org.gradle.api.Project类，并且能够通过project变量使其隐式可用。</p>
<span id="more"></span>

<h2 id="1-Project相关API"><a href="#1-Project相关API" class="headerlink" title="1.Project相关API"></a>1.Project相关API</h2><p>Project提供了一系列操作Project对象的API。如下：</p>
<pre><code>//返回工程RootProject
Project getRootProject();

//返回父Project，在RootProject中调用会返回null
@Nullable
Project getParent();

//返回当前Project
Project getProject();

//返回一个Project的Set集合，包含当前Project和所有子Project
Set&lt;Project&gt; getAllprojects();

//返回一个Project的Set集合，包含所有子Project
Set&lt;Project&gt; getSubprojects();

//返回指定路径的Project，找不到时返回null
@Nullable
Project findProject(String path);

//返回指定路径的Project，不存在时抛出UnknownProjectException
Project project(String path) throws UnknownProjectException;

//为所有子Project增加配置
void subprojects(Closure var1);

//为当前Project以及所有子Project增加配置
void allprojects(Closure var1);
</code></pre>
<h2 id="2-Project属性相关API"><a href="#2-Project属性相关API" class="headerlink" title="2.Project属性相关API"></a>2.Project属性相关API</h2><p>Project提供了一系列操作属性的API，通过属性API可以实现在Project之间共享配置参数。如下：</p>
<pre><code>//默认属性
//默认的build文件名
String DEFAULT_BUILD_FILE = &quot;build.gradle&quot;;
//路径分隔符
String PATH_SEPARATOR = &quot;:&quot;;
//每个工程默认的输出文件夹名称
String DEFAULT_BUILD_DIR_NAME = &quot;build&quot;;

//是否存在指定属性名
boolean hasProperty(String propertyName);

//设置属性值，如果属性不存在则抛出MissingPropertyException
void setProperty(String name, @Nullable Object value) throws MissingPropertyException;

//获取属性值，如果不存在则抛出MissingPropertyException
@Nullable
Object property(String propertyName) throws MissingPropertyException;

//查找属性值，如果不存在返回null
@Nullable
Object findProperty(String propertyName);
</code></pre>
<h3 id="2-1-ext扩展属性"><a href="#2-1-ext扩展属性" class="headerlink" title="2.1 ext扩展属性"></a>2.1 ext扩展属性</h3><p>gradle为Project提供了ext命名空间，用于定义扩展属性。子Project会继承父Project定义的ext属性，但是只读的。我们经常会在Root Project中定义ext属性，而在子Project中可以直接复用属性值。</p>
<h2 id="3-Project文件相关API"><a href="#3-Project文件相关API" class="headerlink" title="3.Project文件相关API"></a>3.Project文件相关API</h2><h3 id="3-1-文件获取相关"><a href="#3-1-文件获取相关" class="headerlink" title="3.1 文件获取相关"></a>3.1 文件获取相关</h3><pre><code>//获取Project根目录(非项目根目录)
File getRootDir();

//build文件夹目录
File getBuildDir();

//获取项目目录
File getProjectDir();
</code></pre>
<h3 id="3-2-文件定位相关"><a href="#3-2-文件定位相关" class="headerlink" title="3.2 文件定位相关"></a>3.2 文件定位相关</h3><pre><code>//获取单个文件，相对当前Project目录
File file(Object path);

//获取多个文件，相对当前Project目录
ConfigurableFileCollection files(Object... paths);
</code></pre>
<h3 id="3-3-文件拷贝"><a href="#3-3-文件拷贝" class="headerlink" title="3.3 文件拷贝"></a>3.3 文件拷贝</h3><p>//文件拷贝，接受闭包作为参数。<br>WorkResult copy(Closure var1);<br>使用如下：</p>
<pre><code>copy &#123;
    //文件来源
    from file(‘a.jks’)
    //目的地
    into getRootProject().getBuildDir().path + &quot;/apk/&quot;

    exclude &#123;
        //排除不需要拷贝的文件
    &#125;

    rename &#123;
        //重命名
    &#125;
&#125;
</code></pre>
<h3 id="3-4-文件遍历"><a href="#3-4-文件遍历" class="headerlink" title="3.4 文件遍历"></a>3.4 文件遍历</h3><p>//将指定目录转化为文件树<br>ConfigurableFileTree fileTree(Object path);</p>
<p>使用如下：</p>
<pre><code>fileTree(&#39;build/output/apk&#39;)&#123; FileTree fileTree -&gt;
    fileTree.visit&#123; FileTreeElement fileTreeElement -&gt;
    
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle学习（三）：Task核心API</title>
    <url>/2023/07/06/gradle-task/</url>
    <content><![CDATA[<p>Project的构建逻辑是一系列Task组成，每个Task负责完成一个基本工作。在配置阶段，Gradle会根据Task的依赖关系构造一个有向无环图，以便在执行阶段按照依赖关系执行Task。</p>
<span id="more"></span>
<h2 id="1-创建简单Task"><a href="#1-创建简单Task" class="headerlink" title="1.创建简单Task"></a>1.创建简单Task</h2><ul>
<li><p>通过task关键字：</p>
<pre><code>task MyTask &#123;
  //配置代码
&#125;
</code></pre>
</li>
<li><p>通过Project的TaskContainer属性也可以创建Task，分为热创建和懒创建：<br>① Task create(String name, Closure configureClosure)热创建：立即实例化Task对象；<br>② TaskProvider register(String name, Action&lt;? super Task&gt; configurationAction)懒创建：注册Task构造器，但不会实例化对象。创建Task操作会延迟到访问该Task时，例如通过TaskCollection#getByName(java.lang.String)，或者TaskProvider#get().</p>
</li>
</ul>
<pre><code>project.tasks.create(name: &quot;MyTask&quot;) &#123;
    //配置代码
&#125;
</code></pre>
<p>TaskContainer负责管理Task实例。以上方式创建的Task都会被加入TaskContainer中。</p>
<h2 id="2-自定义Task"><a href="#2-自定义Task" class="headerlink" title="2.自定义Task"></a>2.自定义Task</h2><p>除了使用简单方式创建Task，我们还可以自定义Task类型。Gradle将这类Task称为增强Task。增强Task的可重用性更好，并且可以通过暴露属性的方式来定制Task的行为。</p>
<ul>
<li><p>1.DefaultTask<br>自定义Task必须继承DefaultTask。</p>
<pre><code>class MyTask extends DefaultTask &#123;
  final String message
  final int number
&#125;
</code></pre>
</li>
<li><p>2.带参数创建Task<br>除了可以在创建Task后配置属性值，我们也可以在调用TaskContainer#create()时传递构造器参数。为了将值传递给任务构造器函数，必须使用@<code>Inject</code> 注解修饰构造器。</p>
<pre><code>class MyTask extends DefaultTask &#123;
  final String message
  final int number

  @Inject
  MyTask(String msg, int num) &#123;
      this.message = msg
      this.number = num
  &#125;
&#125;
</code></pre>
<p>使用TaskContainer#create()创建如下：</p>
<pre><code>//第二个参数为Task类型
tasks.register(&#39;myTask&#39;, MyTask, &#39;Hello&#39;, 29)
</code></pre>
<h2 id="3-获取已创建的Task"><a href="#3-获取已创建的Task" class="headerlink" title="3.获取已创建的Task"></a>3.获取已创建的Task</h2><p>可以获取TaskContainer中已创建的任务，对于通过register注册的任务会在这个时机实例化。</p>
</li>
<li><p>Task getByName(String): 获取Task，如果不存在则抛出异常unknownTaskException；</p>
</li>
<li><p>Task findByName(String): 获取Task，如果Task不存在则返回null。</p>
<pre><code>project.tasks.getByName(&quot;myTask&quot;)
</code></pre>
</li>
</ul>
<h2 id="4-设置Task属性"><a href="#4-设置Task属性" class="headerlink" title="4.设置Task属性"></a>4.设置Task属性</h2><p>设置Task属性的语法主要有三种：</p>
<ul>
<li><p>1.创建Task时设置</p>
<pre><code>task MyTask(group: &quot;MyGroup&quot;)
</code></pre>
</li>
<li><p>2.通过setter方法设置</p>
<pre><code>task MyTask &#123;
  group = &quot;MyGroup&quot; // 等同于 setGroup(&quot;MyGroup&quot;)
&#125;
</code></pre>
</li>
<li><p>3.通过ext额外属性设置: Task也支持与Project类似的额外属性。</p>
<pre><code>task MyTask(group: &quot;MyGroup&quot;) &#123;
  ext.goods = 2
&#125;
</code></pre>
<p>Task常用的自有属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>Task标识符，定义Task时指定</td>
</tr>
<tr>
<td>group</td>
<td>Task所属的组</td>
</tr>
<tr>
<td>description</td>
<td>Task的描述信息</td>
</tr>
<tr>
<td>type</td>
<td>Task类型，默认为DefaultTask</td>
</tr>
<tr>
<td>actions</td>
<td>动作列表</td>
</tr>
<tr>
<td>dependsOn</td>
<td>依赖列表</td>
</tr>
</tbody></table>
</li>
<li><p>Android Studio的Gradle面板会按照<code>group</code>属性对Task进行分组显示。其中，Tasks组为Root Project中的Task，其它分组为各个Project中的Task，未指定group的Task会分配到other分组。<br><img src="task.png" alt="task"></p>
</li>
</ul>
<h2 id="5-执行Task"><a href="#5-执行Task" class="headerlink" title="5.执行Task"></a>5.执行Task</h2><ul>
<li>1.命令行：gradlew :[模块名]:[任务名]。例如：gradlew -q :app:dependencies </li>
<li>2.IDE工具：通过IDE提供的用户界面工具执行，例如Gradle面板或者绿色三角形，支持普通执行和调试执行；</li>
<li>3.默认任务：通过Project#defaultTasks可以指定Project配置阶段的默认任务，在配置阶段会执行配置代码。</li>
</ul>
<pre><code>defaultTasks &#39;MyTask&#39;,&#39;HelloTask&#39;

task MyTask(group:&#39;MyTask&#39;) &#123;
    println &quot;defaultTask MyTask&quot;
&#125;

task HelloTask(group:&#39;MyTask&#39;) &#123;
    println &quot;defaultTask HelloTask&quot;
&#125;
</code></pre>
<h2 id="6-Task-Action动作"><a href="#6-Task-Action动作" class="headerlink" title="6.Task Action动作"></a>6.Task Action动作</h2><p>每个Task内部都保持了一个Action列表actions，执行Task就是按照顺序执行这个列表，Action是比Task更细的代码单元。Task支持添加多个动作，提供了两种方法来添加Action：</p>
<ul>
<li>doFirst(Closure): 在Action列表头部添加一个Action</li>
<li>doLast(Closure): 在Action列表末尾添加一个Action</li>
</ul>
<pre><code>task MyTask(group:&#39;MyTask&#39;) &#123;
    println &quot;defaultTask MyTask&quot;
&#125;

MyTask.doFirst &#123;
    println &quot;MyTask doFirst&quot;
&#125;

MyTask.doLast &#123;
    println &quot;MyTask doLast&quot;
&#125;
</code></pre>
<p>对于自定义Task，还可以通过<code>@TaskAction</code>注解添加默认Action。</p>
<pre><code>class MyTask extends DefaultTask &#123;
   
   @TaskAction
   def sayHello() &#123;
        println &quot;MyTask hello&quot;
   &#125;
&#125;
</code></pre>
<h2 id="7-跳过Task的执行"><a href="#7-跳过Task的执行" class="headerlink" title="7.跳过Task的执行"></a>7.跳过Task的执行</h2><p>Gradle提供了多个方法来控制跳过Task的执行：</p>
<ul>
<li>onlyIf{}：闭包会在即将执行Task之前执行，闭包返回值决定了是否执行Task；</li>
<li>enable属性：Task的enable属性默认为true，设置为false表示无效任务，不需要执行。</li>
</ul>
<h2 id="8-Task依赖关系"><a href="#8-Task依赖关系" class="headerlink" title="8.Task依赖关系"></a>8.Task依赖关系</h2><p>通过建立Task的依赖关系可以构建完整的Task有向无环图：</p>
<ul>
<li>dependsOn强依赖：Task通过dependsOn属性建立强依赖关系，可以直接通过dependsOn属性设置依赖列表，也可以通过dependsOn()方法添加一个依赖；</li>
<li>输入输出隐式依赖：通过建立Task之间的输入和输出关系，也会隐式建立依赖关系。</li>
</ul>
<pre><code>//MyTask依赖于[HelloTask, GreetTask]，执行MyTask前一定会执行HelloTask和GreetTask
task MyTask(group:&#39;MyTask&#39;, dependsOn:[HelloTask, GreetTask]) &#123;
    println &quot;defaultTask MyTask&quot;
&#125;

MyTask.dependsOn(HelloTask, GreetTask)
</code></pre>
<p>在某些情况下，控制两个任务的执行顺序非常有用，而不会在这些任务之间引入显示依赖关系，可以理解为弱依赖。任务排序和任务依赖关系之间的主要区别，排序规则不影响将执行哪些任务，只影响任务执行的顺序。</p>
<ul>
<li>mustRunAfter强制顺序：指定强制要求的任务执行属性；</li>
<li>shouldRunAfter非强制顺序：指定非强制的任务执行顺序，在两种情况下会放弃此规则：1、改规则造成环形顺序；2、并行执行并且任务的所有依赖项都已经完成。</li>
</ul>
<h2 id="9-Gradle中的增量编译"><a href="#9-Gradle中的增量编译" class="headerlink" title="9.Gradle中的增量编译"></a>9.Gradle中的增量编译</h2><p>在我们使用的各种工具中，为了提升工作效率，总会使用到各种各样的缓存技术。在Gradle中这种以task组合起来的构建工具也不例外。在Gradle中，这种技术叫做增量构建。这一特性能够节省大量构建时间。例如编译过源文件后就不应该重复编译，除非发生了影响输出的更改（例如修改或删除源文件）；</p>
<p>Gradle通过对比自从上一次构建之后，task的inputs和outputs是否变化，来决定是否跳过执行。如果相同，则Gradle认为task是最新的，从而会跳过执行。在Build Outputs中看到Task名称旁边出现<code>UP-TO-DATE</code>标志，就说明该Task是被跳过的。<br><img src="task2.png" alt="task2"><br>那么在定义Task的输入输出时，要遵循一个原则：如果Task的一个属性会影响输出，那么应该将该属性注册为输入，否则会影响Task执行；相反如果Task的一个属性不会影响输出，那么不应该将该属性注册为输入，否则Task会在不必要时执行。</p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>为了实现增量构建，gradle将每一个task都分为三部分，分别是input输入、任务本身和output输出。下图是一个典型的Java编译的task。<br><img src="task1.png" alt="task1"><br>以上图为例，input就是目标JDK版本、源文件等，output就是编译出来的class文件。<br>增量构建的原理就是监听input的变化，只有input发生变化了，才重新执行task，否则gradle认为可以重用之前的执行结果。</p>
<h3 id="自定义inputs和outputs"><a href="#自定义inputs和outputs" class="headerlink" title="自定义inputs和outputs"></a>自定义inputs和outputs</h3><p>既然task中的input和output在增量构建中这么重要，我们需要了解如何在task中定义input和output。<br>如果我们自定义一个task，那么满足下面两点就可以使用上增量编译了：</p>
<ul>
<li>需要为task中的inputs和outputs添加必要的getter方法；</li>
<li>为getter方法添加对应的注解。</li>
</ul>
<p>Gradle支持三种主要的inputs和outputs类型：</p>
<ul>
<li><p>1.简单类型：简单类型就是所有实现了Serializable接口的类型，比如String和数值。</p>
</li>
<li><p>2.文件类型：文件类型就是File或者FileCollection的衍生类型，或者其他可以作为参数传递给Project.file(java.lang.Object)和Project.files(java.lang.Object…)的类型。</p>
</li>
<li><p>3.嵌套类型：有些自定义类型，本身不属于前面的1和2两种类型，但是它内部含有嵌套的inputs和outputs属性，这样的类型叫做嵌套类型。<br>举个例子，如下：</p>
<pre><code>public class ProcessTemplates extends DefaultTask &#123;
  private TemplateEngineType templateEngine;
  private FileCollection sourceFiles;
  private TemplateData templateData;
  private File outputDir;

  @Input
  public TemplateEngineType getTemplateEngine() &#123;
      return this.templateEngine;
  &#125;

  @InputFiles
  public FileCollection getSourceFiles() &#123;
      return this.sourceFiles;
  &#125;

  @Nested
  public TemplateData getTemplateData() &#123;
      return this.templateData;
  &#125;

  @OutputDirectory
  public File getOutputDir() &#123; return this.outputDir; &#125;

  // 上面四个属性的setter方法

  @TaskAction
  public void processTemplates() &#123;
      // ...
  &#125;
&#125;
</code></pre>
<p>上边的例子，我们定义了4个属性，分别为TemplateEngineType，FileCollection，TemplateData和File。前面三个属性是输入，后面一个属性是输出。<br>除了getter和setter方法之外，我们还需要在getter方法中添加相应的注解：<code>@Input 、@InputFiles 、@Nested 和 @OutputDirectory，</code>除此之外，我们还定义了一个 @TaskAction 表示这个task要做的工作。<br>这里的TemplateEngineType是一个枚举类，因为enum默认是实现Serializable的，所以这里可以作为@Input使用。<br>sourceFiles使用的是FileCollection，表示的是一系列文件的集合，所以可以使用@InputFiles。<br>为什么TemplateData是@Nested类型的呢？我们看下它的实现：</p>
<pre><code>public class TemplateData &#123;
  private String name;
  private Map&lt;String, String&gt; variables;

  public TemplateData(String name, Map&lt;String, String&gt; variables) &#123;
      this.name = name;
      this.variables = new HashMap&lt;&gt;(variables);
  &#125;

  @Input
  public String getName() &#123; return this.name; &#125;

  @Input
  public Map&lt;String, String&gt; getVariables() &#123;
      return this.variables;
  &#125;
&#125;
</code></pre>
<p>可以看到虽然TemplateData本身并不是File或者简单类型，但是它内部的属性是简单类型的，所以TemplateData本身可以看做是@Nested的。<br>使用了这些注解之后，gradle在构建的时候就会检测和上一次构建相比，这些属性有没有发送变化，如果没有发送变化，那么gradle将会直接使用上一次构建生成的缓存。</p>
</li>
</ul>
<p>除了上述的4个注解，Gradle还提供其他几个注解，常用的注解如下：</p>
<ul>
<li>@InputFile：相当于File，表示单个input文件。</li>
<li>@InputDirectory：相当于File，表示单个input目录。</li>
<li>@OutputFile：相当于File，表示输出文件。</li>
<li>@OutputFiles：相当于Map&lt;String, File&gt; 或者 Iterable<File>，表示输出文件。</li>
<li>@OutputDirectories：相当于Map&lt;String, File&gt; 或者 Iterable<File>，表示输出文件。</li>
<li>@Internal：内部属性，不是input也不是output。</li>
</ul>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Homebrew安装</title>
    <url>/2022/07/18/homebrew/</url>
    <content><![CDATA[<p><strong>Homebrew</strong>是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索、等很多实用的功能。简单的一条指令，就可以实现包管理。官网地址：<a href="https://brew.sh/">https://brew.sh</a></p>
<span id="more"></span>

<h2 id="Homebrew安装"><a href="#Homebrew安装" class="headerlink" title="Homebrew安装"></a>Homebrew安装</h2><p>1.打开终端<br>2.输入安装命令</p>
<pre><code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre>
<p>由于国内某些网络原因，导致<code>http://raw.githubusercontent.com</code>无法访问，通常会提示以下错误：</p>
<pre><code>Failed to connect to http://raw.githubusercontent.com port 443: Connection refused
</code></pre>
<p><strong>解决方法：</strong><br>使用国内代理安装，命令行如下：</p>
<pre><code>/bin/bash -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;
</code></pre>
<p>卸载命令行如下：</p>
<pre><code>/bin/bash -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;
</code></pre>
<p>3.检查安装情况<br>执行命令行<code>brew --version</code>，显示Homebrew版本号则表示安装成功。</p>
]]></content>
      <tags>
        <tag>develop tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2020/04/01/jmm/</url>
    <content><![CDATA[<p><code>Java Memory Model</code></p>
<span id="more"></span>

<p><code>Java</code>虚拟机规范中定义了<code>Java</code>内存模型<code>(Java Memory Model，JMM)</code>，用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让<code>Java</code>程序在各种平台下都能达到一致的并发效果。</p>
<p><code>Java</code>内存模型规定了所有的变量都存储在主内存中(此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅仅是虚拟机内存的一部分)。每条线程还有自己的工作内存(可与前面讲的处理器高速缓存类比)，线程的工作内存中保存该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图：<br><img src="jmm.png" alt="关系"><br>这里所讲的主内存、工作内存与<code>Java</code>内存区域中的<code>Java</code>堆、栈、方法区等并不是同一个层次的堆内存的划分，这两者基本上是没有任何关系的。如果两者一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于<code>Java</code>堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件内存，而为了获取更好的运行速度，虚拟机(或者是硬件、操作系统本身的优化措施)可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，<code>Java</code>内存模型中定义了以下8种操作来完成。<code>Java</code>虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>
<ul>
<li><code>lock</code>(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><code>unlock</code>(解锁)：作用于主内存的变量，他把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><code>read</code>(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的<code>load</code>动作使用。</li>
<li><code>load</code>(载入)：作用于工作内存的变量，它把<code>read</code>操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><code>use</code>(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li><code>assign</code>(赋值)：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令是执行这个操作。</li>
<li><code>store</code>(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的<code>write</code>操作使用。</li>
<li><code>write</code>(写入)：作用于主内存的变量，它把<code>store</code>操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行<code>read</code>和<code>load</code>操作，如果要把变量从工作内存同步回主内存，就要按顺序执行<code>store</code>和<code>write</code>操作。注意，<code>Java</code>内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说<code>read</code>和<code>load</code>之间、<code>store</code>与<code>write</code>之间是可以插入其他指令的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle学习（一）：初识Gradle</title>
    <url>/2022/08/29/gradle/</url>
    <content><![CDATA[<p><code>Gradle</code>是一套基于JVM的新一代自动化构建工具。早期，构建只有编译和打包的简单需求。但是现代软件开发的模式改变了，大多数项目都包含有多而杂的技术栈、混合的多种编程语言，并且使用多种测试策略。随着敏捷实践的崛起，构建不得不更早地支持代码集成，以及频繁和简单地交付软件到测试和产品环境。<code>Gradle</code>便是在这一背景下衍生出来的。</p>
<span id="more"></span>
<p>Gradle 的座右铭:</p>
<pre><code>    “让不可能成为可能，让可能变得简单，让简单变得优雅”。
</code></pre>
<h2 id="1-认识Gradle"><a href="#1-认识Gradle" class="headerlink" title="1.认识Gradle"></a>1.认识Gradle</h2><p><code>Gradle</code>是基于JVM构建工具的新一代版本，它从现有的构建工具如Ant和Maven中学到了许多东西，并且把它们的最优思想提升到更高层次。遵循基于约定的构建方式，Gradle可以用一种声明式的方式为你的问题领域建模，它使用一种强大的且具有表达性的基于Groovy的领域特定语言（DSL），而不是XML。因为Gradle是基于JVM的，它允许你使用自己最喜欢的Java或者Groovy语言来编写定制逻辑。</p>
<h3 id="1-1-Gradle的优点"><a href="#1-1-Gradle的优点" class="headerlink" title="1.1 Gradle的优点"></a>1.1 Gradle的优点</h3><ul>
<li>表达性的DSL：Gradle构建脚本采用基于Groovy的DSL领域特定语言，而不是采用传统的XML文件，相比Maven等构建系统更加简洁易读；</li>
<li>基于JVM：Groovy语言基于JVM，这使得Gradle支持Java/Kotlin代码编译构建脚本，你不必成为Groovy的专家才能开始写脚本，降低了Gradle的学习难度。</li>
<li>增量性构建：大型项目可能拥有上百个模块，构建和测试少量代码的改变会消耗很多时间。Gradle支持指定任务的输入和输出进行增量性构建。它准确的找出哪些任务需要跳过，哪些需要构建或者部分构建。同样的思想也应用到多模块项目中，叫做部分构建。</li>
<li>自定义Task：可以构建自己的任务，然后挂接到Gradle构建的生命周期中去。</li>
</ul>
<h3 id="1-2-Gradle工程的基本结构"><a href="#1-2-Gradle工程的基本结构" class="headerlink" title="1.2 Gradle工程的基本结构"></a>1.2 Gradle工程的基本结构</h3><pre><code>├── a-subproject
│   └── build.gradle
├── build.gradle
├── settings.gradle
├── gradle.properties
├── local.properties
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
└── gradlew.bat
</code></pre>
<ul>
<li>settings.gradle文件：确定哪些模块参与构建；</li>
<li>项目级build.gradle文件：定义子模块公共的配置参数；</li>
<li>模块级build.gradle文件：用于定义子模块的配置参数，它可以覆盖项目级build.gradle中定义的配置；</li>
<li>gradle/wrapper：负责自动下载安装项目所需的Gradle环境的脚本；</li>
<li>gradle.properties：项目级gradle配置项，回覆盖全局的配置项；</li>
<li>local.properties：项目的私有属性配置，如SDK安装目录，一般不会被加入版本控制；</li>
<li>gradlew和gradlew.bat：用来执行构建任务的脚本。命令行gradlew使用Gradle Wrapperz执行构建；命令行gradle使用系统环境变量定义的Gradle环境变量进行构建。</li>
</ul>
<h2 id="2-Gradle构建的生命周期"><a href="#2-Gradle构建的生命周期" class="headerlink" title="2 Gradle构建的生命周期"></a>2 Gradle构建的生命周期</h2><p>Gradle将构建划分为三个阶段：初始化阶段<code>（Initialization）</code>、配置阶段<code>（Configuration）</code>、执行阶段<code>（Execution）</code>。通过理解构建的生命周期，可以知道脚本中每个代码单元的执行时机。</p>
<h3 id="2-1-初始化阶段"><a href="#2-1-初始化阶段" class="headerlink" title="2.1 初始化阶段"></a>2.1 初始化阶段</h3><p>Gradle支持单模块和多模块构建。因此初始化阶段需要明确哪些模块将参与构建。主要包含以下几步：</p>
<ul>
<li><p>解析根目录下的<code>settings.gradle</code>文件，并实例化一个<code>settings</code>对象；</p>
</li>
<li><p>执行<code>settings.gradle</code>脚本，<code>settings.gradle</code>中的代码会在初始化阶段执行；</p>
</li>
<li><p>生成<code>Project</code>对象。<code>Gradle</code>会为<code>settings.gradle</code>中<code>include</code>的每个模块实例化一个<code>Project</code>对象。</p>
</li>
</ul>
<h3 id="2-2-配置阶段"><a href="#2-2-配置阶段" class="headerlink" title="2.2 配置阶段"></a>2.2 配置阶段</h3><p>配置阶段，将执行参与构建的每个模块的build.gradle，已完成Project的配置。主要包含以下几步：</p>
<ul>
<li><p>下载依赖和插件；</p>
</li>
<li><p>执行build.gradle中的代码；</p>
</li>
<li><p>根据task的依赖关系构造一个有向无环图<code>（Directed Acyclic Graph）</code>，以便在执行阶段按照依赖关系执行task。</p>
</li>
</ul>
<h3 id="2-3-执行阶段"><a href="#2-3-执行阶段" class="headerlink" title="2.3 执行阶段"></a>2.3 执行阶段</h3><p>配置阶段构造了task有向无环图，执行阶段会按照依赖关系执行task。</p>
<p><font color="#dd0000">注意：<br>Task配置代码在配置阶段执行，Task动作在执行阶段执行；<br>即使是执行单一一个Task，整个工程的初始化阶段和配置阶段也会执行，这是为了支持在执行中访问Gradle构建模型中的任何一部分。<br></font></p>
<h2 id="3-生命周期的监听"><a href="#3-生命周期的监听" class="headerlink" title="3 生命周期的监听"></a>3 生命周期的监听</h2><h3 id="3-1-初始化阶段监听"><a href="#3-1-初始化阶段监听" class="headerlink" title="3.1 初始化阶段监听"></a>3.1 初始化阶段监听</h3><p>初始化阶段包含解析settings.gradle文件、获取setting实例、创建Project实例。可以使用以下代码监听：</p>
<pre><code>//settings配置完毕
this.gradle.settingsEvaluated &#123;
    println &quot;settings Evaluated&quot;
&#125;

//所有Project对象创建完成
this.gradle.projectsLoaded &#123;
    println &quot;projects Loaded&quot;
&#125;
</code></pre>
<h3 id="3-2-配置阶段监听"><a href="#3-2-配置阶段监听" class="headerlink" title="3.2 配置阶段监听"></a>3.2 配置阶段监听</h3><p>Project接口提供了监听当前Project配置阶段执行的方法：</p>
<pre><code>//执行build.gradle之前
project.beforeEvaluate &#123;
    ...
&#125;

//执行build.gradle之后
project.afterEvaluate &#123;
    ...
&#125;
</code></pre>
<p>此外，Gradle接口也提供了配置阶段的监听：</p>
<pre><code>//执行build.gradle之前
gradle.beforeProject &#123;
    
&#125;

//执行build.gradle之后
gradle.afterProject &#123;
    
&#125;

//与上边的方法等价
gradle.addProjectEvaluationListener(new ProjectEvaluationListener() &#123;
    @Override
    void beforeEvaluate(Project project) &#123;

    &#125;

    @Override
    void afterEvaluate(Project project, ProjectState projectState) &#123;

    &#125;
&#125;)

//监听依赖关系解析完毕
gradle.addListener(new DependencyResolutionListener() &#123;
    @Override
    void beforeResolve(ResolvableDependencies resolvableDependencies) &#123;

    &#125;

    @Override
    void afterResolve(ResolvableDependencies resolvableDependencies) &#123;

    &#125;
&#125;)

//task 有向无环图构造完毕
gradle.taskGraph.whenReady &#123;
    
&#125;

//所有的Project的build.gradle执行完毕
gradle.projectsEvaluated &#123;
    
&#125;
</code></pre>
<h3 id="3-3-执行阶段监听"><a href="#3-3-执行阶段监听" class="headerlink" title="3.3 执行阶段监听"></a>3.3 执行阶段监听</h3><pre><code>//监听task执行
gradle.addListener(new TaskExecutionListener() &#123;
    
    //执行前
    @Override
    void beforeExecute(Task task) &#123;

    &#125;

    //执行后
    @Override
    void afterExecute(Task task, TaskState taskState) &#123;

    &#125;
&#125;)

//监听action列表执行
gradle.addListener(new TaskActionListener() &#123;
    
    //开始执行Action列表之前，回调时机略晚于TaskExecutionListener#beforeExecute
    @Override
    void beforeActions(Task task) &#123;

    &#125;

    //执行Action列表之后，回调时机略早于TaskExecutionListener#afterExecute
    @Override
    void afterActions(Task task) &#123;

    &#125;
&#125;)
</code></pre>
<p>监听构建结束：</p>
<pre><code>gradle.buildFinished &#123;
    
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin为什么将class设计成final类型</title>
    <url>/2021/01/02/kotlinclass/</url>
    <content><![CDATA[<p>“<code>Kotlin</code>开发人员为什么将类设计成<code>final</code>类型？”</p>
<span id="more"></span>

<p>继承是所有<code>OOP</code>语言和<code>Java</code>语言不可缺少的组成部分。当创建一个类时，总是在继承，除非已明确指出要从其他类继承，否则就是隐式地从<code>Java</code>的标准根类<code>Object</code>进行继承。</p>
<p>然而当我们初学<code>Kotlin</code>，第一次写下再熟悉不过的继承语法，编辑器往往会出乎意料的提示你，你要继承的类是<code>final</code>类型，是否需要使它<code>open</code>？默认不能继承？？？需要加<code>open</code>关键字？？？</p>
<p>带着疑问，我们打开<code>Kotlin</code>官方文档。在类与继承部分中提到：<code>Kotlin</code>类是<code>final</code>的，他们不能被继承。要使一个类可被继承，请使用<code>open</code>关键字标记它。</p>
<p><code>open class Base //该类开放继承</code></p>
<p>那么<code>Kotlin</code>为什么要将类设计成默认不可继承呢？</p>
<p>我们先来聊聊<code>Java</code>中的继承。</p>
<p>在面向对象的语言中，继承是必不可少、非常优秀的语言机制，它有如下优点：</p>
<ul>
<li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</li>
<li>提高代码的重用性；</li>
<li>子类可以形似父类，但又异于父类；</li>
<li>提高代码的可扩展性；</li>
</ul>
<p>然而自然界的所有事物都是优点和缺点并存的。继承的缺点如下：</p>
<ul>
<li>继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；</li>
<li>降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；</li>
<li>增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果————大量的代码需要重构。</li>
</ul>
<p>继承是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。使用不当会导致软件变得很脆弱。在包的内部使用继承是非常安全的，在那里，子类和超类的实现都处在同一个程序员的控制下。对于专门为了继承而设计、并且具有很好的文档说明的类来说，使用继承也是非常安全的。然而，对普通的具体类进行跨越包边界的继承，则是非常危险的。</p>
<p>与方法调用不同的是，继承打破了封装性。换句话说，子类依赖于其超类中特定功能的实现细节。超类的实现有可能会随着发行版本的不同而有所变化，如果真的发生了变化，子类可能会遭到破坏，即使它的代码完全没有改变。因而，子类必须要跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。</p>
<p>幸运的是，有一种办法可以避免前面提到的所有问题。</p>
<p>不用扩展现有的类，而是在新类中增加一个私有域，它引用现有类的一个实例。这种设计被称为“复合”，因为现有的类变成了新类的一个组件。新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果。这被称为转发，新类中的方法被称为转发方法。这样得到的类将会非常稳固，它不依赖现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。</p>
<p>所以继承和复合该怎样选择呢？</p>
<p>只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在<code>is-a</code>关系的时候，类B才应该扩展类A。如果你打算让类B扩展类A，那就该问问自己：每个B确实也是A吗？如果你不能够确定这个问题的答案是肯定的，那么B就不该扩展A。如果答案是否定的，通常情况下，B应该包含A的一个私有实例，并且暴露一个较小的、较简单的API：A本质上不是B的一部分，只是它的实现细节而已。</p>
<p>在<code>Java</code>平台类库中，有许多明显违反这条原则的地方。例如，栈<code>（stack）</code>并不是向量<code>（vector）</code>，所以<code>Stack</code>不应该扩展<code>Vector</code>。同样地，属性列表也不是散列表，所以<code>Properties</code>不应该扩展<code>Hashtable</code>。在这两种情况下，复合模式才是恰当的。</p>
<p>如果在适合使用复合的地方使用了继承，则会不必要地暴露实现细节。这样得到的API会把你限制在原始的实现上，永远限定了类的性能。更为严重的是，由于暴露了内部的细节，客户端就有可能直接访问这些内部细节。这样至少会导致语义上的混淆。例如，如果<code>p</code>指向<code>Properties</code>实例，那么<code>p.getProperty(key)</code>就有可能产生与<code>p.get(key)</code>不同的结果：前者考虑了默认的属性表，而后者是继承自<code>Hashtable</code>的，它则没有考虑默认属性列表。最严重的是，客户端有可能直接修改超类，从而破坏子类的约束条件。在<code>Properties</code>的情形中，设计者的目标是，只允许字符串作为键<code>（key）</code>和值<code>（value）</code>，但是直接访问底层的<code>Hashtable</code>就可以违背这种约束条件。一旦违背了这种约束条件，就不可能再使用<code>Properties API</code>的其它部分<code>（load和store）</code>了。</p>
<p>简而言之，继承的功能非常强大，但是也存在着诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类处在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性。为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。</p>
<p>所以，<code>Kotlin</code>中将类设计成final类型时为了提醒开发者慎用继承，如果你考虑清楚确实需要使用继承，那么就给类加<code>open</code>关键字吧！</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>相见欢·林花谢了春红</title>
    <url>/2023/07/16/liyu-poem1/</url>
    <content><![CDATA[<pre><code>相见欢·林花谢了春红
李煜[五代]

林花谢了春红，太匆匆。无奈朝来寒雨晚来风。

胭脂泪，相留醉，几时重。自是人生长恨水长东。
</code></pre>
]]></content>
      <categories>
        <category>唐诗宋词</category>
      </categories>
      <tags>
        <tag>诗词摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin常用的8种循环遍历方法</title>
    <url>/2023/07/27/kt-loop/</url>
    <content><![CDATA[<p>本篇文章整理一下Kotlin常用的循环遍历写法。</p>
<span id="more"></span>
<p>我们经常会使用以下方法进行遍历。</p>
<pre><code>for(i in 0..args.size - 1) &#123;
    println(args[i])
&#125;
</code></pre>
<blockquote>
<p>Tips: Koltin可以通过调用kotlin.ranges包中的<code>rangeTo()</code>函数及其操作符形式的<code>..</code>轻松的创建两个值的区间。通常<code>rangTo</code>会辅以<code>in</code>或者<code>!in</code>函数。整数类型区间（IntRange、LongRange、CharRange）还有一个拓展特性：可以对对其进行迭代。这些区间也是相应类型的等差数列。这种区间通常用于for循环中迭代。要反向迭代数字，使用<code>downTo</code>函数。也可以通过任意步长（不一定为1）迭代数字，通过<code>step</code>完成。 要迭代不包含其结束元素的数字区间（左闭右开区间），使用<code>until</code>函数。</p>
</blockquote>
<pre><code>for (i in 1..4) &#123; //等同于1 &lt;= i &amp;&amp; i &lt;= 4
    print(i)
&#125;

for (i in 4 downTo 1) print(i) //输出结果：4321

for (i in 1..8 step 2) print(i) //输出：1357

for (i in 1 until 10) &#123; // i in [1, 10), 10被排除
    print(i)
&#125;
</code></pre>
<p>但是Array有一个可读性更强的扩展属性lastIndex。上边的循环可以写成这样：</p>
<pre><code>for(i in 0..args.lastIndex) &#123;
    println(args[i])
&#125;
</code></pre>
<p>实际上我们不需要知道最后一个索引，有一个更简单的写法：</p>
<pre><code>for(i in 0 until args.szie) &#123;
    println(args[i])
&#125;
</code></pre>
<p>当然也可以使用下标扩展属性indices得到他的范围，indices是一个IntRange类型的值：</p>
<pre><code>for (i in args.indices) &#123;
    println(args[i])
&#125;
</code></pre>
<p>还有一个更加直接的写法，通过下边的方式直接迭代集合：</p>
<pre><code>for (arg in args) &#123;
    println(arg)
&#125;
</code></pre>
<p>或者还可以使用<code>forEach</code>函数，传递一个lambda表达式来处理每个元素：</p>
<pre><code>args.forEach &#123; arg -&gt;
    println(arg)
&#125;
</code></pre>
<p>在上边这些例子中，都增加一个索引变量，并在循环中通过索引获取元素。但是如果我们迭代的是List，最后两个例子底层使用iterator，而其他的例子仍是通过索引获取元素。最后的两个遍历方法：<br><code>withIndex</code>函数，他返回一个<code>Iterable</code>对象，该对象可以被解构为当前索引和元素:</p>
<pre><code>for ((index,arg) in args.withIndex()) &#123;
    println(&quot;$index: $arg&quot;)
&#125;
</code></pre>
<p><code>forEachIndexed</code>函数，他为每个索引和参数提供了一个lambda表达式：</p>
<pre><code>args.forEachIndexed &#123; index, arg -&gt;  
    println(&quot;$index: $arg&quot;)
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域</title>
    <url>/2020/04/02/memory/</url>
    <content><![CDATA[<p><code>Java</code>虚拟机在执行<code>Java</code>程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域可以分为两个部分：一部分是线程共享的，一部分是线程私有的。其中，线程私有的数据区包括虚拟机栈、本地方法栈和程序计数器。线程共享的数据区具体包括<code>Java</code>堆和方法区两个区域。</p>
<span id="more"></span>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程是<code>CPU</code>调度的基本单位，多线程情况下，当线程数超过<code>CPU</code>数量或<code>CPU</code>内核数时，线程之间就要根据时间片轮询抢夺<code>CPU</code>时间资源。也就是说，在任何一个确定的时刻，一个处理器都只会执行一条线程中指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。程序计数器是线程私有的一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈描述的是<code>Java</code>方法执行的内存模型，是线程私有的。每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，而且每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。其中，局部变量表主要存放一些基本类型的变量<code>（int，short、long、byte、float、double、boolean、char）</code>和对象句柄，他们可以是方法参数，亦可以是方法的局部变量。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与<code>Java</code>虚拟机栈非常类似，也是线程私有的，区别是虚拟机栈为虚拟机执行<code>Java</code>方法服务，而本地方法栈为虚拟机执行<code>Native</code>方法服务。与虚拟机栈一样，本地方法栈区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p><code>Java</code>堆的唯一目的就是存放对象实例，几乎所有的对象实例（和数组）都在这里分配内存。<code>Java</code>堆是线程共享的，类的对象从中分配空间，他们不需要程序代码来显示释放。<code>Java</code>堆是垃圾收集器管理的主要区域，因此很多时候也被称为<code>“GC堆”</code>，从内存回收角度看，由于现在的垃圾收集器基本都采用分代收集算法，所以为了方便垃圾回收<code>Java</code>堆还可以分为新生代和老年代。<code>Java</code>堆在实现时，既可以时固定大小的，也可以是可扩展的。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，会抛出<code>OutOfMemoryError</code>异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与<code>Java</code>堆一样，也是线程共享的并且不需要连续的内存，其用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区又包含常量池：常量池用于存放编译期生成的各种字面量和符号引用。其中，字面量比较接近<code>Java</code>语言层次的常量概念，如文本字符串、被声明为<code>final</code>的常量值等；而符号引用则属于编译原理方面的概念，包括以下三类常量：类和接口的全限定名、字段的名称和描述符和方法的名称和描述符。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的内存结构</title>
    <url>/2020/03/25/object/</url>
    <content><![CDATA[<p>“<code>Java</code>中对象的内存结构是怎样的呢？”</p>
<span id="more"></span>

<p>对象在内存中存储的布局可以分为3块区域：对象头<code>（Header）</code>、实例数据<code>（Instance Data）</code>和对齐填充<code>（Padding）</code>。</p>
<h2 id="1-对象头的结构"><a href="#1-对象头的结构" class="headerlink" title="1.对象头的结构"></a>1.对象头的结构</h2><p><code>HotSpot</code>虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为<code>“Mark Word”</code>；对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h2 id="2-实例数据"><a href="#2-实例数据" class="headerlink" title="2.实例数据"></a>2.实例数据</h2><p>实例数据部分是对象真正存储的有效信息，也既是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录下来。</p>
<h2 id="3-对其填充"><a href="#3-对其填充" class="headerlink" title="3.对其填充"></a>3.对其填充</h2><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于<code>HotSpot VM</code>的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数，因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Oh My Zsh 「安装 &amp; 配置」</title>
    <url>/2022/07/18/ohmyzsh/</url>
    <content><![CDATA[<p><code>Oh My Zsh</code>是一款社区驱动的命令行工具。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。<code>Oh My Zsh</code>官网：<a href="https://ohmyz.sh/">https://ohmyz.sh</a></p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>Curl安装：</strong><br>使用国内镜像安装：</p>
<pre><code>sh -c &quot;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&quot;
</code></pre>
<p><strong>wget安装：</strong><br>使用国内镜像安装：</p>
<pre><code>sh -c &quot;$(wget -O- https://gitee.com/pocmon/mirrors/raw/master/tools/install.sh)&quot;
</code></pre>
<h2 id="配置iterm2命令自动提示"><a href="#配置iterm2命令自动提示" class="headerlink" title="配置iterm2命令自动提示"></a>配置iterm2命令自动提示</h2><p>1.切换到<code>Oh My Zsh</code>的<code>Plugin</code>目录下，下载插件：</p>
<pre><code>$ cd ~/.oh-my-zsh/plugins/
$ git clone https://github.com/zsh-users/zsh-autosuggestions
</code></pre>
<p>2.编辑隐藏文件<code>~/.zshrc</code>，找到<code>plugins=(git)</code>一行，添加下边的代码：</p>
<pre><code>plugins=(git zsh-autosuggestions)
</code></pre>
<p>3.让<code>~/.zshrc</code>配置生效。执行命令：<code>source ~/.zshrc</code></p>
<p>至此，自动提示的插件也就安装完成啦。</p>
]]></content>
      <tags>
        <tag>develop tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable 和 Parcelable</title>
    <url>/2023/07/08/serializable-parcelable/</url>
    <content><![CDATA[<p>什么是序列化？</p>
<p>序列化本质上就是把对象内存中的数据按照一定规则，变成一系列的字节数据（二进制数据），然后再把这些字节数据写入到流中。而反序列化的过程则相反，先读取字节数据，然后再重新组装成Java对象。</p>
<span id="more"></span>

<h2 id="序列化的目的"><a href="#序列化的目的" class="headerlink" title="序列化的目的"></a>序列化的目的</h2><ul>
<li>永久的保存对象数据（将对象数据保存在文件当中，或者磁盘中）</li>
<li>通过序列化操作将对象数据在网络上进行传输（由于网络传输是以字节流的方式对数据进行传输的，因此序列化的目的是将对象数据转换成字节流的形式）</li>
<li>将对象数据在进程之间传递</li>
<li>序列化对象的时候只是针对变量进行序列化，不针对方法进行序列化</li>
<li>在Intent之间，基本数据类型直接进行相关传递即可，但是一旦数据类型比较复杂的时候，就需要进行序列化操作了</li>
</ul>
<h2 id="Android中实现序列化的两种方式"><a href="#Android中实现序列化的两种方式" class="headerlink" title="Android中实现序列化的两种方式"></a>Android中实现序列化的两种方式</h2><p>1.implements Serializable接口<br>2.implements Parcelable接口（还需要实现接口内部的相应方法，写入数据的顺序和读出数据的顺序必须相同）</p>
<h2 id="Serializable原理"><a href="#Serializable原理" class="headerlink" title="Serializable原理"></a>Serializable原理</h2><p>Java中的对象流操作是通过ObjectInputStream和ObjectOutputStream这两个流对象来实现的，在两个对象的使用过程中，源码里会判断对象是否实现Serializable接口，否则会抛出<code>java.io.NotSerializableException</code>。Serializable也可以自定义序列化过程，实现writeObject和readObject方法即可。</p>
<p>1.Serializable只是一个接口，本身没有任何实现；<br>2.对象的反序列化并没有调用对象的任何构造方法；<br>3.serialVersionUID是用于记录文件版本信息的，最好能够自定义。否则系统会自动生成一个serialVersionUID，文件或者对象的任何改变，都会改变serialVersionUID，导致反序列化的失败，如果自定义就没有这个问题；<br>4.如果某个属性不想实现序列化，可以采用transient修饰；<br>5.Serializable的系统实现是采用ObjectOutputStream和ObjectInputStream实现的，这也是为什么调用ObjectInputStream和ObjectOutputStream时，需要对应的类实现Serializable接口。</p>
<h2 id="使用Parcelable进行序列化操作"><a href="#使用Parcelable进行序列化操作" class="headerlink" title="使用Parcelable进行序列化操作"></a>使用Parcelable进行序列化操作</h2><p>1.writeToParcel将对象数据序列化成一个Parcel对象；<br>2.重写describeContents方法，默认值为0；<br>3.public static final Creator<T> CREATOR同时需要实现两个方法：<br>    createFromParcel(Parcel in)从Parcel容器中取出数据并进行转换<br>    newArray(int size) 返回对象数据的大小</p>
<h2 id="Parcelable原理"><a href="#Parcelable原理" class="headerlink" title="Parcelable原理"></a>Parcelable原理</h2><p>无论是对数据的读还是写都需要使用Parcel作为中间层将数据进行传递。通过JNI相互调用，在java层先创建Parcel对象，然后在调用相关的读写操作时，首先将Java的Parcel对象转换成Parcel c++对象，然后被封装在Parcel中的相关数据由c++底层完成数据的序列化操作。<br>源码参考：<br><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_os_Parcel.cpp">https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_os_Parcel.cpp</a></p>
<p><a href="https://cs.android.com/android/platform/superproject/+/refs/heads/master:frameworks/native/libs/binder/Parcel.cpp">https://cs.android.com/android/platform/superproject/+/refs/heads/master:frameworks/native/libs/binder/Parcel.cpp</a></p>
<ul>
<li>整个读写全是在内存中进行，主要是通过malloc()、realloc()、memcpy()等内存操作进行，所以效率比Java系列化中使用外部存储器会高很多</li>
<li>对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()实现的，目的是反序列化时读出的对象就是原对象而不是重新new一个新对象。</li>
</ul>
<h2 id="使用时如何选择"><a href="#使用时如何选择" class="headerlink" title="使用时如何选择"></a>使用时如何选择</h2><ul>
<li>内存方面，Parcelable比Serializable性能高，所以推荐使用Parcelable。</li>
<li>Serializable在序列化的时候会产生大量的临时变量，从而引起频繁GC。</li>
<li>Parcelable不能使用在要将数据存储在磁盘的情况，此时建议使用Serializable。</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th></th>
<th>Serializable</th>
<th>Parcelable</th>
</tr>
</thead>
<tbody><tr>
<td>存储媒介</td>
<td>IO读写存储在硬盘上</td>
<td>直接在内存中读写</td>
</tr>
<tr>
<td>性能</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>使用</td>
<td>实现接口即可</td>
<td>需要编写代码</td>
</tr>
<tr>
<td>效率</td>
<td>大量使用反射，效率低</td>
<td>内存操作，效率高</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举单例</title>
    <url>/2020/08/21/singleton/</url>
    <content><![CDATA[<p>单例模式是应用最广泛的模式之一。在应用这个模式时，单例对象的类必须保证只有一个实例存在。</p>
<span id="more"></span>

<p>实现单例模式主要有以下几个关键点：<br>1.构造函数一般不对外开放，一般为private；<br>2.通过一个静态方法或者枚举返回单例类对象；<br>3.确保单例类的对象有且只有一个，尤其是在多线程环境下；<br>4.确保单例类对象在反序列化时不会重新构建对象。</p>
<h2 id="常见的单例实现方式"><a href="#常见的单例实现方式" class="headerlink" title="常见的单例实现方式"></a>常见的单例实现方式</h2><p>常见的单例实现方式有懒汉模式、DCL、静态内部类单例模式。上述的几种单例模式实现中，在反序列化的情况下它们会出现重建对象。</p>
<p>我们知道通过序列化可以将一个单例的对象的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数是私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。反序列化提供了一个很特别的钩子函数，类中具有一个私有的<code>readResolve()</code>函数，这个函数可以让开发人员控制对象的反序列化。如果想杜绝单例对象在被反序列化时重新生成对象，那么必须加入<code>readResolve</code>函数。</p>
<pre><code>public final class Singleton implements Serializable &#123;
    private static final long serialVersionUID = 0L；
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() &#123;
    &#125;

    public static Singleton getInstance() &#123;
        return INSTANCE;
    &#125;

    private Object readResolve() throws ObjectStreamException &#123;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<p>而对于枚举单例，不仅写法简单，最重要的是默认枚举实例的创建是线程安全的，并且在任何情况下他都是一个单例。<br>《Effective Java》在谈到枚举单例中写到：这种方法在功能上与公有域方法相近，但是它更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
<h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>枚举单例实现方式如下</p>
<pre><code>public enum SingletonEnum &#123;
    INSTANCE;
    public void doSomething() &#123;

    &#125;
&#125;
</code></pre>
<p>那么枚举单例是怎样保证线程安全的呢？</p>
<p>我们查看SingletonEnum.java文件编译后的字节码文件。如下：</p>
<p><img src="singleton.png" alt="alt"></p>
<p>可以看出，编译之后会生成一个继承自<code>java.lang.Enum</code>的<code>final class</code> SingletonEnum类，申明的枚举实例对应一个用<code>static final</code>修饰的变量，其初始化在静态块中完成。所以本质上线程安全也是通过类加载过程中，类构造器的调用实现了同步。</p>
<p>又是如何保证反射安全呢？继续看代码</p>
<p><img src="singleton1.png" alt="alt"></p>
<p>原来在<code>java.lang.reflect.Constructor</code>类的<code>newInstance()</code>方法中进行了类型判断。如果是Enum类型，则会直接抛出异常。</p>
<p>那么，序列化安全又是如何保证的呢？<br>通过阅读<code>ObjectOutputStream</code>类的<code>writeEnum()</code>方法和<code>ObjectInputStream</code>的<code>readEnum()</code>方法可知，序列化时，当为<code>Enum</code>类型时，只会把<code>Enum</code>类型中定义的<code>name</code><br>属性输出到结果中。反序列化时，就调用<code>Enum</code>的<code>T valueOf(Class&lt;T&gt; enumType, String name)</code>方法，根据<code>name</code>拿到Enum实例。</p>
<p>同时，编译器是不允许任何对这种序列化进行定制，因此禁用了<code>writeObject、readObject、readObjectNoData</code>方法。并且<code>Enum</code>私有化了构造函数，且禁用了<code>clone()</code>方法，防止通过<code>new</code>和克隆创造对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>经典垃圾收集器</title>
    <url>/2020/04/18/collectors/</url>
    <content><![CDATA[<p>如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。</p>
<span id="more"></span>

<p><img src="collectors.png" alt="经典垃圾收集器"></p>
<h3 id="一-Serial收集器"><a href="#一-Serial收集器" class="headerlink" title="一.Serial收集器"></a>一.Serial收集器</h3><p><code>Serial</code>收集器是最基础、历史最悠久的收集器，曾经(在<code>JDK1.3.1</code>之前)是<code>HotSpot</code>虚拟机新生代收集器的唯一选择。看名字就能猜到，这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或者一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其它所有工作线程，直到它收集结束。<code>“Stop The World”</code>这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。</p>
<p>事实上，迄今为止，<code>Serial</code>收集器依然是<code>HotSpot</code>虚拟机运行在客户端模式下的默认新生代收集器，有着优先于其它收集器的地方，那就是简单而高效(与其它收集器的单线程比较)，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核处理器或者处理核心数较少的环境来说，<code>Serial</code>收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<p>下图为<code>Serial/Serial Old</code>收集器运行示意图：<br><img src="serial.png" alt="serial垃圾收集器"></p>
<h3 id="二-ParNew收集器"><a href="#二-ParNew收集器" class="headerlink" title="二.ParNew收集器"></a>二.ParNew收集器</h3><p><code>ParNew</code>收集器实质上是<code>Serial</code>收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括<code>Serial</code>收集器可用的所有控制参数、收集算法、<code>Stop The World</code>、对象分配规则、回收策略等都与<code>Serial</code>收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>
<p><code>ParNew/Serial Old</code>收集器运行示意图：<br><img src="parnew.png" alt="parnew垃圾收集器"><br><code>ParNew</code>收集器除了支持多线程并行收集之外，其它与<code>Serial</code>收集器相比并没有太多创新之处，但它却是不少运行在服务器模式下的<code>HotSpot</code>虚拟机，尤其是<code>JDK7</code>之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要得原因：除了<code>Serial</code>收集器外，目前只有它能与<code>CMS</code>收集器配合工作。<code>ParNew</code>收集器是激活<code>CMS</code>后的默认新生代收集器。可以说直到<code>CMS</code>的出现才巩固<code>ParNew</code>的地位，但成也萧何败也萧何，随着垃圾收集器技术的不断改进，更先进的<code>G1</code>收集器带着<code>CMS</code>继承者和替代者的光环登场。<code>G1</code>是一个面向全堆得收集器，不需要其他新生代收集器的配合工作。所以自<code>JDK9</code>开始，<code>ParNew</code>加<code>CMS</code>收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被<code>G1</code>所取代，甚至还取消了<code>ParNew</code>加<code>Serial Old</code>以及<code>Serial</code>加<code>CMS</code>这两组收集器组合的支持，这意味着<code>ParNew</code>和<code>CMS</code>从此只能互相搭配使用，再也没有其他收集器能够和它们配合了。也可以理解从此<code>ParNew</code>合并入<code>CMS</code>，成为它专门处理新生代的组成部分。<code>ParNew</code>可以说是<code>HotSpot</code>虚拟机中第一款退出历史舞台的垃圾收集器。</p>
<p><code>ParNew</code>处理器在单核心处理器的环境中绝对不会有比<code>Serial</code>收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的伪双核处理器环境中都不能百分百保证超越<code>Serial</code>收集器。当然，随着可以使用的处理器核心数量的增加，<code>ParNew</code>对于垃圾收集时系统资源的高效利用还是有很多好处的。</p>
<h3 id="三-Parallel-Scavenge收集器"><a href="#三-Parallel-Scavenge收集器" class="headerlink" title="三.Parallel Scavenge收集器"></a>三.Parallel Scavenge收集器</h3><p><code>Parallel Scavenge</code>收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，<code>Parallel Scavenge</code>的诸多特性从表面上看和<code>ParNew</code>非常相似，那它有什么特别之处呢？<br><code>Parallel Scavenge</code>收集器的特点是它的关注点与其它收集器不同，<code>CMS</code>等收集器的关注点是尽可能低缩短垃圾收集时用户线程的停顿时间，而<code>Parallel Scavenge</code>收集器的目标则是达到一个可控制的吞吐量。所谓吞吐量就是处理器运行代码的事件与处理器总消耗事件的比值(吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间))。也就是说<code>CMS</code>等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而<code>Parallel Scavenge</code>收集器关注的是吞吐量，而高吞吐量则可以最高效的利用处理器资源，尽快完成程序的运算任务，所以适合做后台运算等不需要太多用户交互的任务。</p>
<p><code>Parallel Scavenge</code>收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的<code>-XX:MAXGCPauseMillis</code>参数及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>（默认99%）。<br>除了以上两个参数，还可以用<code>Parallel Scavenge</code>收集器提供的第三个参数<code>-XX:UseAdaptiveSizePolicy</code>，开启这个参数后，就不需要手工指定新生代大小、<code>Eden</code>与<code>Survivor</code>比例等细节，只需要设置好基本的堆大小，以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是<code>Parallel Scavenge</code>与<code>ParNew</code>的重要区别。</p>
<h3 id="四-Serial-Old收集器"><a href="#四-Serial-Old收集器" class="headerlink" title="四.Serial Old收集器"></a>四.Serial Old收集器</h3><p><code>Serial Old</code>是<code>Serial</code>收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是提供客户端模式下的<code>HotSpot</code>虚拟机使用。如果在服务端模式下，他可能有两种用途：一种是在<code>JDK5</code>以及之前的版本中与<code>Parallel Scavenge</code>收集器搭配使用，另外一种就是作为<code>CMS</code>收集器发生失败时的后备预案。它与<code>Serial</code>收集器配合使用示意图如下：<br><img src="serial.png" alt="serialold垃圾收集器"></p>
<h3 id="五-Parallel-Old收集器"><a href="#五-Parallel-Old收集器" class="headerlink" title="五.Parallel Old收集器"></a>五.Parallel Old收集器</h3><p><code>Parallel Old</code>收集器是<code>Parallel Scavenge</code>收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器是直到<code>JDK6</code>时才开始提供的，在此之前，新生代<code>Parallel Scavenge</code>收集器一直处于相当尴尬的状态，原因是如果新生代选择了<code>Parallel Scavenge</code>收集器，老年代除了<code>Serial Old</code>收集器以外别无选择，其它表现良好的老年代收集器，如<code>CMS</code>无法与它配合工作。由于老年代<code>Serial Old</code>收集器在服务端应用性能上的拖累，使用<code>Parallel Scavenge</code>收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集器中无法充分利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的优势设置不一定比<code>ParNew</code>加<code>CMS</code>的组合来的优秀。</p>
<p>直到<code>Parallel Old</code>收集器出现后，吞吐量优先收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑<code>Parallel Scavenge</code>加<code>Parallel Old</code>收集器这个组合。<code>Parallel Scavenge</code>和<code>Parallel Old</code>收集器运行示意图如下：<br><img src="parallelold.png" alt="parallelold垃圾收集器"></p>
<h3 id="六-CMS收集器"><a href="#六-CMS收集器" class="headerlink" title="六.CMS收集器"></a>六.CMS收集器</h3><p><code>CMS(Concurrent Mark Sweep)</code>收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的<code>Java</code>应用集中在互联网网站或者基于浏览器的<code>B/S</code>系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，已给用户带来良好的交互体验。<code>CMS</code>收集器就非常适合这类应用的需求。</p>
<p>从名字上就可以看出<code>CMS</code>收集器是基于标记-清除算法实现的，他的运作过程对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ol>
<p>其中初始标记、重新标记这两个步骤仍然需要<code>“Stop The World”</code>。初始标记仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，速度很快；并发标记阶段就是从<code>GC Roots</code>的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，<code>CMS</code>收集器的内存回收过程是与用户线程一起并发执行的。<code>CMS</code>垃圾收集器运行示意图如下：<br><img src="cms.png" alt="cms垃圾收集器"></p>
<p><code>CMS</code>是一款优秀的收集器，它最主要的有点在名字上已经体现出来：并发收集、低停顿。<code>CMS</code>收集器是<code>HotSpot</code>虚拟机追求低停顿的第一次成功尝试，但它还远达不到完美的程度，至少有以下三个明显的缺点：</p>
<ul>
<li><p>首先，<code>CMS</code>收集器对处理器资源非常敏感。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，他虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。<code>CMS</code>默认启动的回收线程数是(处理器核心数量 + 3)/4，也就是说，如果处理器核心数在四个以上，并发回收时垃圾收集线程占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，<code>CMS</code>对用户线程的影响就可能变得很大。</p>
</li>
<li><p>然后，由于<code>CMS</code>收集器无法处理浮动垃圾，有可能出现<code>“Concurrent Mode Failure”</code>而导致另一次完全的<code>“Stop The World”</code>的<code>Full GC</code>的产生。在<code>CMS</code>的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，<code>CMS</code>无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就被称为浮动垃圾。同样也是由于此原因，那就还需要预留足够内存空间提供给用户线程使用，因此<code>CMS</code>收集器不能像其它收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。要是<code>CMS</code>运行期间预留的内存无法满足程序分配新对象的需求，就会出现一次并发失败，这时候虚拟机不得不启动后备预案：冻结用户线程的执行，临时启用<code>Serial Old</code>收集器来重新进行老年代的垃圾收集，但这样停顿时间就更长了。</p>
</li>
<li><p><code>CMS</code>采用的是标记清除法，这意味着收集结束后会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不触发一次<code>Full GC</code>的情况。</p>
</li>
</ul>
<h3 id="七-Garbage-First收集器"><a href="#七-Garbage-First收集器" class="headerlink" title="七.Garbage First收集器"></a>七.Garbage First收集器</h3><p><code>Garbage First</code>（简称<code>G1</code>）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思想和基于<code>Region</code>的内存布局形成。<code>G1</code>是一款主要面向服务端应用的垃圾收集器。主要有以下几个特点：</p>
<ul>
<li>像<code>CMS</code>收集器一样，能与应用程序线程并发执行</li>
<li>整理空闲空间更快</li>
<li>需要<code>GC</code>停顿时间更好预测</li>
<li>不会像<code>CMS</code>那样牺牲大量的吞吐性能</li>
<li>不需要更大的<code>Java Heap</code></li>
</ul>
<p>与<code>CMS</code>相比，它在以下两个方面表现出色：</p>
<ol>
<li>运作期间不会产生内存碎片，<code>G1</code>从整体上看是采用的是标记-整理法，局部(两个<code>Region</code>)上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。</li>
<li>在<code>STW</code>上建立了可预测的停顿时间模型，用户可指定期望停顿时间，<code>G1</code>会将停顿时间控制在用户设定的停顿时间以内。</li>
</ol>
<p>为什么<code>G1</code>能建立可预测的停顿模型呢？首先是思想上的转变，在<code>G1</code>收集器出现之前的所有其它收集器，垃圾收集的目标范围要么是整个新生代<code>(Minor GC)</code>，要么就是整个老年代<code>(Major GC)</code>，再要么就是整个<code>Java</code>堆<code>(Full GC)</code>。而<code>G1</code>跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集(<code>Collection Set</code>，一般简称<code>CSet</code>)进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是<code>G1</code>收集器的<code>Mixed GC</code>模式。</p>
<p><code>G1</code>开创的基于<code>Region</code>的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其它收集器有非常明显的差异：<code>G1</code>不再坚持固定大小以及固定数量的分代区域划分，而是把连续的<code>Java</code>堆划分为多个大小相等的独立区域<code>(Region)</code>，每一个<code>Region</code>都可以根据需要，扮演新生代的<code>Eden</code>空间、<code>Survivor</code>空间，或者老年代空间。收集器能够对扮演不同角色的<code>Region</code>采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能够取得很好的收集效果。</p>
<p><code>Region</code>中还有一类特殊的<code>Humongous</code>区域，专门用来存储大对象。<code>G1</code>认为只要大小超过了一个<code>Region</code>容量的一半的对象即可判定为大对象。这样超大对象直接分配到了老年代，防止了反复拷贝移动。<br><img src="g1.png" alt="g1垃圾收集器"></p>
<p>虽然<code>G1</code>仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域(不需要连续)的动态集合。<code>G1</code>收集器之所以能建立可预测的停顿时间模型，是因为它将<code>Region</code>作为单次回收的最小单元，即每次收集到的内存空间都是<code>Region</code>大小的整数倍，这样可以有计划地避免在整个<code>Java</code>堆中进行全区域的垃圾收集。更具体的处理思路是让<code>G1</code>收集器去跟踪各个<code>Region</code>里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些<code>Region</code>，这就是<code>“Garbage First”</code>名字的由来。</p>
<p>那么<code>G1</code>分配成这样有什么好处呢？传统的收集器如果发生<code>Full GC</code>是对整个堆进行全区域的垃圾收集，而分配成各个<code>Region</code>的话，方便<code>G1</code>跟踪各个<code>Region</code>里垃圾堆积的价值大小(回收所获得的空间大小及回收所需要的经验值)，这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的<code>Region</code>，也就避免了整个老年代的回收，也就减少了<code>STW</code>造成的停顿时间。同时由于只收集部分<code>Region</code>，可就做到了<code>STW</code>时间的可控。这种使用<code>Region</code>划分内存空间，以及具有优先级的区域回收方式，保证了<code>G1</code>收集器在有限时间内获取尽可能高的收集效率。</p>
<p><code>G1</code>收集器的运作过程大致可划分为以下四个步骤：</p>
<ol>
<li>初始标记：仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象</li>
<li>并发标记：从<code>GC Root</code>开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时比较长，但是可以与用户程序并发执行。</li>
<li>最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来最后那少量的<code>SATB</code>记录。</li>
<li>筛选回收：负责更新<code>Region</code>的统计数据，对各个<code>Region</code>的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个<code>Region</code>构成回收集，然后把决定回收那一部分<code>Region</code>的存活对象复制到空的<code>Region</code>中，再清理掉整个旧的<code>Region</code>的全部空间。这里的操作设计存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ol>
<p><code>G1</code>收集器运行示意图如下：<br><img src="g1pic.png" alt="g1垃圾收集器"><br>从上述阶段的描述可以看出，<code>G1</code>收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹的追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才能担当的起全功能收集器的重任与期望。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
</search>
